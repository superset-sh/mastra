---
title: "Reference: E2BSandbox | Workspace"
description: "Documentation for the E2BSandbox provider for isolated cloud code execution."
packages:
  - "@mastra/e2b"
---

# E2BSandbox

Executes commands in isolated [E2B](https://e2b.dev) cloud sandboxes. Provides secure, ephemeral environments with support for mounting cloud storage.

:::info

For interface details, see [WorkspaceSandbox interface](/reference/workspace/sandbox).

:::

## Installation

```bash
npm install @mastra/e2b
```

## Usage

Add an `E2BSandbox` to a workspace and assign it to an agent:

```typescript
import { Agent } from '@mastra/core/agent'
import { Workspace } from '@mastra/core/workspace'
import { E2BSandbox } from '@mastra/e2b'

const workspace = new Workspace({
  sandbox: new E2BSandbox({
    id: 'dev-sandbox',
    timeout: 60_000, // 60 second timeout (default: 5 minutes)
  }),
})

const agent = new Agent({
  name: 'dev-agent',
  model: 'anthropic/claude-opus-4-5',
  workspace,
})
```

## Constructor parameters

<PropertiesTable
  content={[
{
name: "apiKey",
type: "string",
description: "E2B API key. Falls back to E2B_API_KEY environment variable.",
isOptional: true,
},
{
name: "timeout",
type: "number",
description: "Execution timeout in milliseconds",
isOptional: true,
defaultValue: "300000 (5 minutes)",
},
{
name: "template",
type: "string | TemplateBuilder | function",
description: "Sandbox template specification. Can be a template ID string, a TemplateBuilder, or a function that customizes the default template.",
isOptional: true,
},
{
name: "env",
type: "Record<string, string>",
description: "Environment variables to set in the sandbox",
isOptional: true,
},
{
name: "id",
type: "string",
description: "Unique identifier for this sandbox instance",
isOptional: true,
defaultValue: "Auto-generated",
},
{
name: "domain",
type: "string",
description: "Domain for self-hosted E2B. Falls back to E2B_DOMAIN env var.",
isOptional: true,
},
{
name: "apiUrl",
type: "string",
description: "API URL for self-hosted E2B. Falls back to E2B_API_URL env var.",
isOptional: true,
},
{
name: "accessToken",
type: "string",
description: "Access token for authentication. Falls back to E2B_ACCESS_TOKEN env var.",
isOptional: true,
},
]}
/>

## Properties

<PropertiesTable
  content={[
{
name: "id",
type: "string",
description: "Sandbox instance identifier",
},
{
name: "name",
type: "string",
description: "Provider name ('E2BSandbox')",
},
{
name: "provider",
type: "string",
description: "Provider identifier ('e2b')",
},
{
name: "status",
type: "ProviderStatus",
description: "'pending' | 'initializing' | 'ready' | 'error'",
},
{
name: "supportsMounting",
type: "boolean",
description: "Always true - E2B sandboxes support mounting cloud filesystems",
},
]}
/>

## Methods

### `start()`

Initialize and start the sandbox. Creates the E2B sandbox instance and mounts any configured filesystems.

```typescript
await sandbox.start()
```

Called automatically on first command execution or by `workspace.init()`.

### `stop()`

Stop the sandbox and release resources.

```typescript
await sandbox.stop()
```

### `destroy()`

Clean up sandbox resources completely.

```typescript
await sandbox.destroy()
```

### `executeCommand(command, args?, options?)`

Execute a shell command in the sandbox.

```typescript
const result = await sandbox.executeCommand('ls', ['-la'])
const npmResult = await sandbox.executeCommand('npm', ['install', 'lodash'], {
  timeout: 60000,
  cwd: '/app',
})
```

**Parameters:**

<PropertiesTable
  content={[
{
name: "command",
type: "string",
description: "Command to execute",
},
{
name: "args",
type: "string[]",
description: "Command arguments",
isOptional: true,
},
{
name: "options.timeout",
type: "number",
description: "Execution timeout in milliseconds",
isOptional: true,
},
{
name: "options.cwd",
type: "string",
description: "Working directory for the command",
isOptional: true,
},
{
name: "options.env",
type: "Record<string, string>",
description: "Additional environment variables",
isOptional: true,
},
{
name: "options.onStdout",
type: "(data: string) => void",
description: "Callback for stdout streaming",
isOptional: true,
},
{
name: "options.onStderr",
type: "(data: string) => void",
description: "Callback for stderr streaming",
isOptional: true,
},
]}
/>

### `canMount(filesystem)`

Check if a filesystem can be mounted into this sandbox.

```typescript
const canMount = sandbox.canMount(s3Filesystem)
// true for S3Filesystem and GCSFilesystem
```

### `mount(filesystem, mountPath)`

Mount a filesystem into the sandbox at the specified path.

```typescript
await sandbox.mount(s3Filesystem, '/mnt/data')
```

### `unmount(mountPath)`

Unmount a previously mounted filesystem.

```typescript
await sandbox.unmount('/mnt/data')
```

### `getInfo()`

Get sandbox status and resource information.

```typescript
const info = await sandbox.getInfo()
// { id: '...', name: 'E2BSandbox', provider: 'e2b', status: 'ready', supportsMounting: true }
```

## Mounting Cloud Storage

E2B sandboxes can mount S3 or GCS filesystems, making cloud storage accessible as local directories inside the sandbox. This is useful for:

- Processing large datasets stored in cloud buckets
- Writing output files directly to cloud storage
- Sharing data between sandbox sessions

### Using the mounts config

The simplest way to mount filesystems is through the workspace `mounts` config:

```typescript
import { Workspace } from '@mastra/core/workspace'
import { S3Filesystem } from '@mastra/s3'
import { GCSFilesystem } from '@mastra/gcs'
import { E2BSandbox } from '@mastra/e2b'

const workspace = new Workspace({
  mounts: {
    '/s3-data': new S3Filesystem({
      bucket: 'my-s3-bucket',
      region: 'us-east-1',
      accessKeyId: process.env.AWS_ACCESS_KEY_ID,
      secretAccessKey: process.env.AWS_SECRET_ACCESS_KEY,
    }),
    '/gcs-data': new GCSFilesystem({
      bucket: 'my-gcs-bucket',
      projectId: 'my-project',
      credentials: JSON.parse(process.env.GCS_SERVICE_ACCOUNT_KEY),
    }),
  },
  sandbox: new E2BSandbox({ id: 'dev-sandbox' }),
})
```

When the sandbox starts, the filesystems are automatically mounted at the specified paths. Code running in the sandbox can then access files at `/s3-data` and `/gcs-data` as if they were local directories.

### How mounting works

E2B sandboxes use FUSE (Filesystem in Userspace) to mount cloud storage:

- **S3/R2**: Mounted via [s3fs-fuse](https://github.com/s3fs-fuse/s3fs-fuse)
- **GCS**: Mounted via [gcsfuse](https://github.com/GoogleCloudPlatform/gcsfuse)

The E2B sandbox automatically installs the required FUSE tools when mounting is used. For best performance, pre-build a custom template with the tools installed.

## Custom Templates

By default, when no template is specified, E2BSandbox automatically builds a template with `s3fs` installed for S3 mounting support. This template is cached and reused across sandbox instances.

For GCS mounting, `gcsfuse` is automatically installed at mount time if not already present. For additional tools or faster cold starts, use custom templates.

### Using an existing template

If you have a pre-built template, pass its ID:

```typescript
const workspace = new Workspace({
  sandbox: new E2BSandbox({
    id: 'dev-sandbox',
    template: 'my-custom-template',
  }),
})
```

### Customizing the default template

Pass a function to customize the default mountable template. The function receives a `TemplateBuilder` and should return the modified template:

```typescript
const workspace = new Workspace({
  sandbox: new E2BSandbox({
    template: base =>
      base
        .aptInstall(['ffmpeg', 'imagemagick', 'poppler-utils'])
        .pipInstall(['pandas', 'numpy'])
        .npmInstall(['sharp']),
  }),
})
```

The template builder supports method chaining with operations like:

- `aptInstall(packages)` - Install system packages
- `pipInstall(packages)` - Install Python packages
- `npmInstall(packages)` - Install Node.js packages
- `runCmd(command)` - Run shell commands
- `setEnvs(vars)` - Set environment variables
- `copy(src, dest)` - Copy files into the template

See [E2B's template documentation](https://e2b.dev/docs/template/defining-template) for the full list of available methods.

### Pre-building templates

The default template is built on first use and cached. For faster cold starts or to include GCS support, you can pre-build a template:

```typescript
import { createDefaultMountableTemplate } from '@mastra/e2b'
import { Template } from 'e2b'

// Get the default mountable template (includes s3fs)
const { template, id } = createDefaultMountableTemplate()

// Build and save to E2B
const result = await Template.build(template, id)
console.log('Template ID:', result.templateId)

// Use this ID in your E2BSandbox config for instant startup
const sandbox = new E2BSandbox({
  template: result.templateId,
})
```

For faster GCS cold starts, pre-install `gcsfuse` in a custom template:

```typescript
const workspace = new Workspace({
  sandbox: new E2BSandbox({
    id: 'dev-sandbox',
    template: base => base.aptInstall(['gcsfuse']),
  }),
})
```

This is optionalâ€”`gcsfuse` is installed automatically at mount time if not present.

## Related

- [WorkspaceSandbox interface](/reference/workspace/sandbox)
- [LocalSandbox reference](/reference/workspace/local-sandbox)
- [S3Filesystem reference](/reference/workspace/s3-filesystem)
- [GCSFilesystem reference](/reference/workspace/gcs-filesystem)
- [Workspace overview](/docs/workspace/overview)
