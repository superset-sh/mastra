---
title: "Reference: Run.timeTravel() | Workflows"
description: Documentation for the `Run.timeTravel()` method in workflows, which re-executes a workflow from a specific step.
packages:
  - "@mastra/core"
---

# Run.timeTravel()

The `.timeTravel()` method re-executes a workflow starting from any specific step, using either stored snapshot data or custom context you provide. This is useful for debugging failed workflows, testing individual steps with different inputs, or recovering from errors without re-running the entire workflow.

## Usage example

```typescript
const run = await workflow.createRun()

const result = await run.timeTravel({
  step: 'step2',
  inputData: { value: 10 },
})
```

## Parameters

<PropertiesTable
  content={[
{
name: "step",
type: "Step<string, any, TInputSchema, any, any, any, TEngineType> | [...Step<string, any, any, any, any, any, TEngineType>[], Step<string, any, TInputSchema, any, any, any, TEngineType>] | string | string[]",
description:
"The target step to start execution from. It can be a Step instance, array of Steps (for nested workflows), step ID string, or array of step ID strings. Use dot notation or arrays for nested workflow steps (e.g., 'nestedWorkflow.step3' or ['nestedWorkflow', 'step3'])",
isOptional: false,
},
{
name: "inputData",
type: "z.infer<TInputSchema>",
description: "Input data for the target step. Must match the step's input schema. If not provided, uses data from the workflow snapshot",
isOptional: true,
},
{
name: "resumeData",
type: "any",
description: "Resume data to provide if the workflow was previously suspended",
isOptional: true,
},
{
name: "initialState",
type: "z.infer<TState>",
description: "Initial state to set for the workflow run. Used to set workflow-level state before execution",
isOptional: true,
},
{
name: "context",
type: "TimeTravelContext<any, any, any, any>",
description:
"Execution context containing step results for steps before the target step. Each key is a step ID with a StepResult object containing status, payload, output, startedAt, endedAt, suspendPayload, and resumePayload",
isOptional: true,
},
{
name: "nestedStepsContext",
type: "Record<string, TimeTravelContext<any, any, any, any>>",
description:
"Context for nested workflow steps. Keyed by nested workflow ID, each containing step results for that nested workflow",
isOptional: true,
},
{
name: "requestContext",
type: "RequestContext",
description: "Request Context data to use during time travel execution",
isOptional: true,
},
{
name: "outputWriter",
type: "(chunk: TOutput) => Promise<void>",
description: "Optional asynchronous function to handle output chunks as they are produced",
isOptional: true,
},
{
name: "tracingContext",
type: "TracingContext",
isOptional: true,
description:
"Tracing context for creating child spans and adding metadata. Automatically injected when using Mastra's tracing system.",
properties: [
{
parameters: [
{
name: "currentSpan",
type: "Span",
isOptional: true,
description:
"Current span for creating child spans and adding metadata. Use this to create custom child spans or update span attributes during execution.",
},
],
},
],
},
{
name: "tracingOptions",
type: "TracingOptions",
isOptional: true,
description: "Options for Tracing configuration.",
properties: [
{
parameters: [
{
name: "metadata",
type: "Record<string, any>",
isOptional: true,
description:
"Metadata to add to the root trace span. Useful for adding custom attributes like user IDs, session IDs, or feature flags.",
},
],
},
{
parameters: [
{
name: "requestContextKeys",
type: "string[]",
isOptional: true,
description:
"Additional RequestContext keys to extract as metadata for this trace. Supports dot notation for nested values (e.g., 'user.id').",
},
],
},
{
parameters: [
{
name: "traceId",
type: "string",
isOptional: true,
description:
"Trace ID to use for this execution (1-32 hexadecimal characters). If provided, this trace will be part of the specified trace.",
},
],
},
{
parameters: [
{
name: "parentSpanId",
type: "string",
isOptional: true,
description:
"Parent span ID to use for this execution (1-16 hexadecimal characters). If provided, the root span will be created as a child of this span.",
},
],
},
{
parameters: [
{
name: "tags",
type: "string[]",
isOptional: true,
description:
"Tags to apply to this trace. String labels for categorizing and filtering traces.",
},
],
},
],
},
{
name: "outputOptions",
type: "OutputOptions",
isOptional: true,
description: "Options for output configuration.",
properties: [
{
parameters: [
{
name: "includeState",
type: "boolean",
isOptional: true,
description:
"Whether to include the workflow run state in the result.",
},
],
},
{
parameters: [
{
name: "includeResumeLabels",
type: "boolean",
isOptional: true,
description:
"Whether to include resume labels in the result.",
},
],
},
],
},
]}
/>

## Returns

<PropertiesTable
  content={[
{
name: "result",
type: "Promise<WorkflowResult<TState, TInput, TOutput, TSteps>>",
description:
"A promise that resolves to the workflow execution result containing step outputs and status",
},
{
name: "traceId",
type: "string",
isOptional: true,
description:
"The trace ID associated with this execution when Tracing is enabled. Use this to correlate logs and debug execution flow.",
},
]}
/>

## Extended usage examples

### Time travel with custom context

```typescript
const result = await run.timeTravel({
  step: 'step2',
  context: {
    step1: {
      status: 'success',
      payload: { value: 0 },
      output: { step1Result: 2 },
      startedAt: Date.now(),
      endedAt: Date.now(),
    },
  },
})
```

### Time travel to nested workflow step

```typescript
// Using dot notation
const result = await run.timeTravel({
  step: 'nestedWorkflow.step3',
  inputData: { value: 10 },
})

// Using array of step IDs
const result = await run.timeTravel({
  step: ['nestedWorkflow', 'step3'],
  inputData: { value: 10 },
})
```

### Time travel with initial state

```typescript
const result = await run.timeTravel({
  step: 'step2',
  inputData: { value: 10 },
  initialState: {
    counter: 5,
    metadata: { source: 'time-travel' },
  },
})
```

### Time travel with nested workflows context

```typescript
const result = await run.timeTravel({
  step: 'nestedWorkflow.step3',
  context: {
    step1: {
      status: 'success',
      payload: { value: 0 },
      output: { step1Result: 2 },
      startedAt: Date.now(),
      endedAt: Date.now(),
    },
    nestedWorkflow: {
      status: 'running',
      payload: { step1Result: 2 },
      startedAt: Date.now(),
    },
  },
  nestedStepsContext: {
    nestedWorkflow: {
      step2: {
        status: 'success',
        payload: { step1Result: 2 },
        output: { step2Result: 3 },
        startedAt: Date.now(),
        endedAt: Date.now(),
      },
    },
  },
})
```

## Notes

- Time travel requires storage to be configured since it relies on persisted workflow snapshots
- When re-executing a workflow, the workflow loads the existing snapshot from storage (if available)
- Step results before the target step are reconstructed from the snapshot or provided context
- Execution begins from the specified step with the provided or reconstructed input data
- The workflow continues to completion from that point forward
- Time travel can be used on workflows that have not been run yet by providing custom context or input data for the step to start from.

## Related

- [Time Travel](/docs/workflows/time-travel)
- [Workflows overview](/docs/workflows/overview#running-workflows)
- [Workflow.createRun()](../workflow-methods/create-run)
- [Snapshots](/docs/workflows/snapshots)
- [Suspend & Resume](/docs/workflows/suspend-and-resume)
